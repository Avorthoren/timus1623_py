"""


Maximum number of nodes for 5 rooms and 20 doors on depth 19 (consider outer
room is on depth 0) is 476837158203120, or ~~ 5 * 10^14.

Сдаётся мне, что я не на совсем уж правильном пути.
Есть лабиринты, которые требуют погружения на DOORS уровней.
Также, я легко могу построить лабиринт с максимальным числом нод так (5 комнат, 20 дверей), чтоб они все (кроме финиша)
были доступны. А это больше чем 4.7 * 10^14 нод для 20 уровней глубины.
Так что мне нужно думать о чём-то более хитром чем просто ограничить глубину сверху.

Если есть дорога 0.a-0.b, то есть дорога r.a-r.b для всех r.
Если есть дорога 0.a-r.a, то есть бесконечная дорога. (нужно ли это?)

1. Строим набор областей связности A для первого уровня используя шаблонное описание алгоритма.
Повторить `DOORS - 1` раз:
2. Выделяем из этого набор областей связности B нулевого уровня. Накладываем это на каждую внутреннюю комнату, получая
новые связи для внутренних комнат. Обновляем A.

test.hard_unsolvable_test_links_gen(rooms=2, doors=4):
STEP 0:
A:
00 10 01
11 02 20
12 03
13
21
22
23
B:
00 01
02
03

STEP 1:
NEW LINKS FROM B:
10 11  # merges first two groups of A
20 21  # merges them further with fifth group.
A:
00 10 01 11 02 20 21
12 03
13
22
23
B:
00 01 02
03

STEP 2:
NEW LINKS FROM B:
10 12  # merges first two groups of A
11 12  # same
20 22  # merges them further with fourth group
21 22  # same
A:
00 10 01 11 02 20 21 12 03 22
13
23
B:
00 01 02 03

NOW 00 and 03 in one group -> done
"""

import os

LOCAL = bool(int(os.environ.get('LOCAL', '0')))


def main():
	...


if __name__ == "__main__":
	main()
